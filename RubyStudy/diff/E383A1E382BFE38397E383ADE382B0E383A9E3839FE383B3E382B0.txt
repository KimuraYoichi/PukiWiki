-*メタプログラミングRuby [#rd12c57e]
-**オブジェクトモデル [#l6684bbc]
-+オープンクラス
-+クラスの真実
-+メソッドを呼び出すときに何が起きているの？
-**メソッド [#o20d1ed5]
-+動的メソッド
-+method_missing()
-**ブロック [#t9b5ab2e]
-+クロージャ
-+instance_eval()
-+Procオブジェクト
-**クラス定義 [#y258abf3]
-+クラス定義
--~クラス定義の中にはあらゆるコードを置くことが出来る。
--~クラス定義も最後の命令文の値を返す。
--~クラスもselfになれる。+カレントクラス
 
-+カレントクラス
--rubyは常にカレントオブジェクトselfを持っている。同様に、常にカレントクラス（あるいはモジュール）も持っている。
--メソッドを定義すると、それはカレントクラスのインスタンスメソッドになる。
--classキーワードでクラスをオープン（あるいはmoduleキーワードでモジュールをオープンすると）、そのクラスがカレントクラスになる。
- result= class MyClass
-  self                
- end                  
- result => MyClass
-+クラス名が判らないときにクラスをオープンするには？？ 
--Module#class_eval()は、既存のクラスのコンテキストでブロックを評価する。
--class_eval()
- def add_method_to(a_class)
-  a_class.class_eval do
-    def m; 'Hello!' ; end
-  end
- end
- add_method_to String
- "abc".m=> "Hello!"
--class_eval()は、classが常数を必要とするのに対して、class_eval()はクラスを参照する変数なら何でも使える。
--classは現在の束縛を捨てて、新しいスコープをオープンするに対してclass_eval()はフラットスコープを持つ。
--すなわち、class_eval()ブロックのスコープ外にある変数も参照できる。
- "カレントクラスのまとめ"
- -クラス定義のなかでは、カレントオブジェクトselfは定義されたクラスである。
- -Rubyのインタプリタは常にカレントクラス（あるいはモジュール）の参照を追跡している。defで定義されたすべてのメソッドは、カレントクラスのインスタンスメソッドになる。
- -クラス定義のなかでは、カレントクラスのselfと同じである。つまり、定義されたクラスである。
- -クラスへの参照を持っていれば、クラスはclass_eval()(あるいはmodule_eval())でオープンできる。
-
